package json_to_go

import (
	"fmt"
	"github.com/tidwall/gjson"
	"strconv"
	"strings"
)

const (
	Root = "AutoGenerated"
)

type meta struct {
	array     bool   // 是否数组
	name      string // 属性名称
	t         Kind   // 数据类型
	omitempty bool   // 是否非空
	children  []meta // 子属性
}

func assertType(value gjson.Result) Kind {
	switch value.Type {
	case gjson.JSON:
		if value.IsArray() {
			arr := value.Array()
			if len(arr) == 0 {
				return Interface
			}
			kindMap := map[Kind]struct{}{}
			for _, i := range arr {
				kindMap[assertType(i)] = struct{}{}
			}
			if len(kindMap) > 1 {
				return Interface
			}
			for k, _ := range kindMap {
				return k
			}
		}
		return Struct
	case gjson.False, gjson.True:
		return Bool
	case gjson.Number:
		if _, err := strconv.ParseInt(value.String(), 10, 64); err != nil {
			return Float64
		}
		return Int64
	case gjson.Null:
		return Interface
	case gjson.String:
		return String
	}
	return Invalid
}

func parse(result gjson.Result) (m []meta) {
	arr := result.Array()
	if len(arr) == 0 {
		return
	}
	var intersectFields []string
	var fieldMap = make(map[string]int)
	for idx, _ := range arr {
		var hasFields []string
		arr[idx].ForEach(func(key, value gjson.Result) bool {
			hasFields = append(hasFields, key.String())
			if _, ok := fieldMap[key.String()]; ok {
				return true
			}
			metaItem := meta{
				array:     value.IsArray(),
				name:      key.String(),
				t:         assertType(value),
				omitempty: true,
				children:  nil,
			}
			if metaItem.t == Struct {
				metaItem.children = parse(value)
			}
			m = append(m, metaItem)
			fieldMap[key.String()] = len(m) - 1
			return true
		})
		if idx == 0 {
			intersectFields = hasFields
		}
		intersectFields = Intersect(hasFields, intersectFields)
	}
	for _, field := range intersectFields {
		if idx, ok := fieldMap[field]; ok && len(m) > idx {
			m[idx].omitempty = false
		}
	}
	return
}

func generateStruct(meta []meta, indent string, inline bool) ([]string, []string) {
	var structDef []string
	var subStructDef []string

	for _, m := range meta {
		var typeStr string
		if m.array {
			typeStr += "[]"
		}
		switch m.t {
		case Struct:
			if inline {
				content := ""
				subInfo, _ := generateStruct(m.children, indent+indent, inline)
				if len(subInfo) > 0 {
					content = fmt.Sprintf("\n%s\n%s", strings.Join(subInfo, "\n"), indent)
				}
				typeStr += fmt.Sprintf("struct {%s}", content)
			} else {
				m.array = false
				subStructDefItems := GenerateStruct(m, inline)
				subStructDef = append(subStructDef, subStructDefItems...)
				typeStr += strings.Title(m.name)
			}
		default:
			typeStr += m.t.String()
		}
		omitemptyStr := ""
		if m.omitempty {
			omitemptyStr = ",omitempty"
		}
		structDef = append(structDef, fmt.Sprintf("%s%s %s `json:\"%s%s\"`",
			indent, ToUpperCamelCase(m.name), typeStr, m.name, omitemptyStr))
	}

	return structDef, subStructDef
}

func Parse(json string) meta {
	result := gjson.Parse(json)

	m := meta{
		array:     result.IsArray(),
		name:      Root,
		t:         assertType(result),
		omitempty: false,
		children:  nil,
	}
	m.children = parse(result)

	return m
}

func GenerateStruct(meta meta, inline bool) []string {
	tpl := "type %s %s%s"
	array := ""
	if meta.array {
		array = "[]"
	}
	switch meta.t {
	case Struct:
		tpl = fmt.Sprintf(tpl, strings.Title(meta.name), array, meta.t.String()+" {%s}")
		content := ""
		info, subStructDef := generateStruct(meta.children, "\t", inline)
		if len(info) > 0 {
			content = fmt.Sprintf("\n%s\n", strings.Join(info, "\n"))
		}
		main := fmt.Sprintf(tpl, content)
		return append([]string{main}, subStructDef...)
	default:
		main := fmt.Sprintf(tpl, meta.name, array, meta.t.String())
		return []string{main}
	}
}
